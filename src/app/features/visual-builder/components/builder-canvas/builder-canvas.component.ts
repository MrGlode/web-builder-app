// src/app/features/visual-builder/components/builder-canvas/builder-canvas.component.ts

import { Component, input, output, signal, computed, inject, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BuilderComponent } from '../../models/component.model';
import { ViewMode } from '../../models/page.model';
import { MultiSelectionService } from '../../services/multi-selection.service';

@Component({
  selector: 'app-builder-canvas',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './builder-canvas.component.html',
  styleUrls: ['./builder-canvas.component.scss']
})
export class BuilderCanvasComponent {
  
  // ===== SERVICES =====
  
  private multiSelectionService = inject(MultiSelectionService);
  
  // ===== INPUTS =====
  
  /** Liste des composants √† afficher */
  components = input<BuilderComponent[]>([]);
  
  /** ID du composant s√©lectionn√© (single selection - legacy) */
  selectedComponentId = input<string | null>(null);
  
  /** Mode de vue actuel */
  viewMode = input<ViewMode>('desktop');
  
  /** Niveau de zoom */
  zoomLevel = input<number>(100);
  
  // ===== OUTPUTS =====
  
  /** √âmis quand un composant est s√©lectionn√© */
  componentSelected = output<BuilderComponent>();
  
  /** √âmis quand plusieurs composants sont s√©lectionn√©s */
  componentsSelected = output<BuilderComponent[]>();
  
  /** √âmis quand un composant est dropp√© sur le canvas */
  componentDropped = output<{ 
    componentType: string; 
    parentId?: string; 
    index?: number 
  }>();
  
  /** √âmis quand un composant est survol√© */
  componentHovered = output<string | null>();
  
  /** √âmis quand les composants s√©lectionn√©s doivent √™tre supprim√©s */
  componentsDeleted = output<string[]>();
  
  /** √âmis quand les composants s√©lectionn√©s doivent √™tre dupliqu√©s */
  componentsDuplicated = output<BuilderComponent[]>();
  
  // ===== STATE =====
  
  /** ID du composant survol√© */
  private hoveredComponentId = signal<string | null>(null);
  
  /** √âtat du drag en cours */
  private isDragging = signal(false);
  
  /** Type de composant en cours de drag */
  private draggedComponentType = signal<string | null>(null);
  
  /** Zone de drop active */
  private activeDropZone = signal<string | null>(null);
  
  /** Mode de s√©lection visuelle (pour feedback UI) */
  private selectionFeedback = signal<'single' | 'multi' | 'range' | null>(null);
  
  // ===== COMPUTED (Multi-Selection) =====
  
  /** IDs des composants s√©lectionn√©s depuis le service */
  selectedIds = this.multiSelectionService.selectedComponentIds;
  
  /** Nombre de composants s√©lectionn√©s */
  selectionCount = this.multiSelectionService.selectionCount;
  
  /** A-t-on une s√©lection multiple ? */
  hasMultipleSelection = this.multiSelectionService.hasMultipleSelection;
  
  /** Mode de s√©lection actuel */
  currentSelectionMode = this.multiSelectionService.currentMode;
  
  /** Indique si on est en train de dragger */
  canvasDragging = computed(() => this.isDragging());
  
  /** Obtient le composant survol√© */
  hoveredComponent = computed(() => {
    const id = this.hoveredComponentId();
    return id ? this.findComponentById(id) : null;
  });
  
  /** Info contextuelle pour l'UI */
  selectionInfo = computed(() => {
    const count = this.selectionCount();
    const mode = this.currentSelectionMode();
    
    if (count === 0) return 'Aucune s√©lection';
    if (count === 1) return '1 composant s√©lectionn√©';
    return `${count} composants s√©lectionn√©s (mode: ${mode})`;
  });
  
  // ===== LIFECYCLE =====
  
  ngOnInit() {
    console.log('üé® Builder Canvas initialis√© avec Multi-Selection');
  }
  
  // ===== M√âTHODES - S√©lection (Am√©lior√©e) =====
  
  /**
   * S√©lectionne un composant avec support multi-s√©lection
   * - Click simple : S√©lection unique
   * - Ctrl+Click : Toggle dans s√©lection multiple
   * - Shift+Click : S√©lection en plage
   */
  selectComponent(component: BuilderComponent, event: MouseEvent) {
    event.stopPropagation();
    
    // D√©terminer le mode de s√©lection
    let mode: 'single' | 'multi' | 'range' = 'single';
    
    if (event.ctrlKey || event.metaKey) {
      mode = 'multi';
    } else if (event.shiftKey) {
      mode = 'range';
    }
    
    // Mise √† jour visuelle du feedback
    this.selectionFeedback.set(mode);
    
    // Utiliser le service de multi-s√©lection
    this.multiSelectionService.select(
      component.id,
      mode,
      this.components()
    );
    
    // √âmettre les √©v√©nements
    this.componentSelected.emit(component);
    
    // Si multi-s√©lection, √©mettre aussi la liste compl√®te
    if (this.hasMultipleSelection()) {
      const selected = this.multiSelectionService.getSelectedComponents(
        this.components()
      );
      this.componentsSelected.emit(selected);
    }
    
    console.log(`üñ±Ô∏è S√©lection ${mode}:`, component.displayName);
  }
  
  /**
   * V√©rifie si un composant est s√©lectionn√©
   */
  isSelected(component: BuilderComponent): boolean {
    return this.multiSelectionService.isSelected(component.id);
  }
  
  /**
   * V√©rifie si un composant est survol√©
   */
  isHovered(component: BuilderComponent): boolean {
    return this.hoveredComponentId() === component.id;
  }
  
  /**
   * D√©s√©lectionne tout (clic sur le canvas vide)
   */
  onCanvasClick(event: MouseEvent) {
    // Seulement si on clique directement sur le canvas
    const target = event.target as HTMLElement;
    if (target.classList.contains('canvas-content') || 
        target.classList.contains('builder-canvas')) {
      this.multiSelectionService.clearSelection();
      this.selectionFeedback.set(null);
      this.componentSelected.emit(null as any);
      console.log('‚ùå D√©s√©lection totale');
    }
  }
  
  // ===== M√âTHODES - Hover =====
  
  /**
   * G√®re le survol d'un composant
   */
  onComponentMouseEnter(component: BuilderComponent, event: Event) {
    event.stopPropagation();
    this.hoveredComponentId.set(component.id);
    this.componentHovered.emit(component.id);
  }
  
  /**
   * G√®re la sortie du survol
   */
  onComponentMouseLeave(component: BuilderComponent, event: Event) {
    event.stopPropagation();
    if (this.hoveredComponentId() === component.id) {
      this.hoveredComponentId.set(null);
      this.componentHovered.emit(null);
    }
  }
  
  // ===== M√âTHODES - Drag & Drop =====
  
  /**
   * G√®re le dragover sur le canvas
   */
  onCanvasDragOver(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'copy';
    }
    
    this.isDragging.set(true);
  }
  
  /**
   * G√®re le dragleave du canvas
   */
  onCanvasDragLeave(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    
    const target = event.target as HTMLElement;
    if (target.classList.contains('canvas-content')) {
      this.isDragging.set(false);
      this.activeDropZone.set(null);
    }
  }
  
  /**
   * G√®re le drop sur le canvas (racine)
   */
  onCanvasDrop(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    
    if (!event.dataTransfer) return;
    
    const componentType = event.dataTransfer.getData('componentType');
    
    if (componentType) {
      console.log('üì¶ Drop sur le canvas (racine):', componentType);
      
      this.componentDropped.emit({
        componentType,
        parentId: undefined,
        index: this.components().length
      });
    }
    
    this.isDragging.set(false);
    this.draggedComponentType.set(null);
    this.activeDropZone.set(null);
  }
  
  /**
   * G√®re le dragover sur un composant container
   */
  onContainerDragOver(event: DragEvent, component: BuilderComponent) {
    event.preventDefault();
    event.stopPropagation();
    
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'copy';
    }
    
    if (this.canHaveChildren(component)) {
      this.activeDropZone.set(component.id);
    }
  }
  
  /**
   * G√®re le drop sur un container
   */
  onContainerDrop(event: DragEvent, component: BuilderComponent) {
    event.preventDefault();
    event.stopPropagation();
    
    if (!event.dataTransfer) return;
    
    const componentType = event.dataTransfer.getData('componentType');
    
    if (componentType && this.canHaveChildren(component)) {
      console.log('üì¶ Drop dans container:', componentType, '‚Üí', component.displayName);
      
      this.componentDropped.emit({
        componentType,
        parentId: component.id,
        index: component.children?.length || 0
      });
    }
    
    this.activeDropZone.set(null);
  }
  
  // ===== RACCOURCIS CLAVIER =====
  
  /**
   * G√®re les raccourcis clavier
   */
  @HostListener('window:keydown', ['$event'])
  handleKeyboard(event: KeyboardEvent): void {
    // Ignorer si on est dans un input/textarea
    const target = event.target as HTMLElement;
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      return;
    }
    
    // Ctrl+A / Cmd+A : Tout s√©lectionner
    if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
      event.preventDefault();
      this.selectAll();
    }
    
    // Escape : D√©s√©lectionner tout
    if (event.key === 'Escape') {
      event.preventDefault();
      this.clearSelection();
    }
    
    // Delete / Backspace : Supprimer la s√©lection
    if (event.key === 'Delete' || event.key === 'Backspace') {
      event.preventDefault();
      this.deleteSelected();
    }
    
    // Ctrl+D / Cmd+D : Dupliquer
    if ((event.ctrlKey || event.metaKey) && event.key === 'd') {
      event.preventDefault();
      this.duplicateSelected();
    }
  }
  
  /**
   * S√©lectionne tous les composants
   */
  selectAll(): void {
    const allIds = this.components().map(c => c.id);
    this.multiSelectionService.selectAll(allIds);
    this.selectionFeedback.set('multi');
    
    const selected = this.multiSelectionService.getSelectedComponents(
      this.components()
    );
    this.componentsSelected.emit(selected);
    
    console.log('‚úÖ Tous les composants s√©lectionn√©s:', allIds.length);
  }
  
  /**
   * D√©s√©lectionne tout
   */
  clearSelection(): void {
    this.multiSelectionService.clearSelection();
    this.selectionFeedback.set(null);
    console.log('‚ùå S√©lection effac√©e');
  }
  
  /**
   * Supprime les composants s√©lectionn√©s
   */
  deleteSelected(): void {
    const selectedIds = this.selectedIds();
    
    if (selectedIds.length === 0) {
      console.log('‚ö†Ô∏è Aucun composant √† supprimer');
      return;
    }
    
    this.componentsDeleted.emit(selectedIds);
    this.multiSelectionService.clearSelection();
    
    console.log(`üóëÔ∏è Suppression de ${selectedIds.length} composant(s)`);
  }
  
  /**
   * Duplique les composants s√©lectionn√©s
   */
  duplicateSelected(): void {
    const selected = this.multiSelectionService.getSelectedComponents(
      this.components()
    );
    
    if (selected.length === 0) {
      console.log('‚ö†Ô∏è Aucun composant √† dupliquer');
      return;
    }
    
    this.componentsDuplicated.emit(selected);
    console.log(`üìã Duplication de ${selected.length} composant(s)`);
  }
  
  // ===== M√âTHODES - Utilitaires =====
  
  /**
   * V√©rifie si un composant peut avoir des enfants
   */
  canHaveChildren(component: BuilderComponent): boolean {
    const containerTypes = [
      'container', 'section', 'grid', 'flexbox', 
      'form', 'card', 'modal', 'tabs', 'accordion'
    ];
    return containerTypes.includes(component.type);
  }
  
  /**
   * V√©rifie si une zone est active pour le drop
   */
  isDropZoneActive(componentId: string): boolean {
    return this.activeDropZone() === componentId;
  }
  
  /**
   * Trouve un composant par son ID (r√©cursif)
   */
  private findComponentById(id: string): BuilderComponent | null {
    const find = (components: BuilderComponent[]): BuilderComponent | null => {
      for (const comp of components) {
        if (comp.id === id) return comp;
        if (comp.children) {
          const found = find(comp.children);
          if (found) return found;
        }
      }
      return null;
    };
    return find(this.components());
  }
  
  /**
   * Obtient l'ic√¥ne d'un composant
   */
  getComponentIcon(component: BuilderComponent): string {
    const icons: Record<string, string> = {
      'container': 'üì¶',
      'section': 'üìÑ',
      'grid': '‚äû',
      'flexbox': '‚¨å',
      'heading': 'üî§',
      'paragraph': 'üìù',
      'button': 'üîò',
      'input': '‚úèÔ∏è',
      'textarea': 'üìÑ',
      'select': 'üìã',
      'checkbox': '‚òëÔ∏è',
      'radio': 'üîò',
      'image': 'üñºÔ∏è',
      'video': 'üé¨',
      'icon': '‚≠ê',
      'form': 'üìã',
      'card': 'üÉè',
      'modal': 'ü™ü',
      'tabs': 'üìë',
      'accordion': 'üìÇ',
      'carousel': 'üé†'
    };
    return icons[component.type] || 'üß©';
  }
  
  /**
   * Obtient le badge de s√©lection
   */
  getSelectionBadge(component: BuilderComponent): string {
    if (!this.isSelected(component)) return '';
    
    const selectedIds = this.selectedIds();
    const index = selectedIds.indexOf(component.id);
    
    if (index === -1) return '';
    return `${index + 1}`;
  }
  
  /**
   * Obtient les statistiques de s√©lection pour l'UI
   */
  getSelectionStats() {
    return {
      count: this.selectionCount(),
      hasMultiple: this.hasMultipleSelection(),
      mode: this.currentSelectionMode(),
      info: this.selectionInfo()
    };
  }
}